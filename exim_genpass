#!/bin/sh

##############################################
#                                            #
# SHA-512 hashed password script for Exim    #
# Copyright (C) 2017 Stuart Cardall          #
#					     #
# Licensed under the terms of the GPL2	     #
# see also secpwgen for password generation: #
# https://github.com/itoffshore/secpwgen     #
#					     #
# sSMTP note: do NOT enclose the password    #
# in "quotes" & do NOT end the password with #
# a = (as generated by secpwgen -r)	     #
					     #
PW_FILE=/etc/exim/passwd		     #
					     #
######### END USER CONFIG ####################

# up to 999,999,999 rounds are possible with:
# Debian mkpasswd & Python's passlib only.
# Busybox mkpasswd & Python / Perl crypt()
# use system default of 5000 rounds.
ROUNDS=${ROUNDS:-1250000}

usage() {
	local script=$(basename $0)
	cat <<EOF
$script: Generate SHA512 hashed passwords [ in $PW_FILE ]

Usage: $script [OPTIONS]
	[ -n ] : Don't update file; display results on stdout.
	[ -f ] : Write username:passwd to a different file. (default: $PW_FILE)
	[ -r ] : use the specified NUMBER of rounds (Debian mkpasswd / Python passlib() only => default: $ROUNDS)
					   (Busybox mkpasswd / Python crypt() / Perl crypt() => 5000 rounds)
	[ -h ] : this help message.

Examples:
 $script		(Update $PW_FILE => username:passwd)
 $script -f file	(Update file => username:passwd)
 $script -n	(Don't update $PW_FILE: display results on stdout)
EOF
	exit 0
}

catch_exits() {
	if [ -n "$PID" ]; then
		printf "\n\nkilling pid: $PID\n"
		kill -9 $PID
	fi
	printf "\n$(basename $0): exiting\n" 1>&2
	exit 1
}

create_salt() {
	local salt=16
	# sha-512 has a maximum salt size of 16 chars
	# https://www.akkadia.org/drepper/SHA-crypt.txt
	printf "$(head /dev/urandom | tr -dc A-Za-z0-9./ | head -c $salt)\n"
}

check_sha512_method() {
	local method= cmd=$1 _outvar=$2

	case "$cmd" in
		   perl) method='Perl crypt()';;
		busybox) method='Busybox mkpasswd';;
		 debian) method='Debian mkpasswd';;
		 python) method='Python:';

			 if has_passlib; then
				method="$method passlib()"
			 else
				method="$method crypt()"
			 fi
			 ;;
		      *) printf "Error in check_sha512_method\n"; catch_exits;;
	esac

	eval "$_outvar=\$method"
}

create_sha512_hash() {
	local hash= password=$1 cmd=$2 _outvar=$3
	local salt=$(create_salt) _ret_py_hash= _ret_py_module=

	# debian mkpasswd & Python passlib can change the # of rounds used to create a hash
	# mkpasswd also exists as a package in Alpine Linux (debian-mkpasswd in Arch Linux)

	case "$cmd" in
		   perl) hash=$(perl -e 'print crypt("'$password'","\$6\$'$salt'\$") . "\n"');;
		busybox) hash=$(mkpasswd -m sha512 $password);;
		 debian) hash=$(mkpasswd -m sha-512 -R $ROUNDS -S $salt);;
		 python) py_sha512 $password $salt _ret_py_hash;
			 hash=$_ret_py_hash;;
	esac

	eval "$_outvar=\$hash"
}

py_mod_check_version() {
	local module=${module%.*}
	python -c "import $module; print $module.__version__" 2>/dev/null
}

compare_version() {
	local required=$1 module=$2
	local installed=$(py_mod_check_version $module) # shells cannot do floating point
	awk -v "REQ=$required" -v "INS=$installed" 'BEGIN { print ( (REQ - INS) * 10 ) }'
}

has_passlib(){
	local module=passlib version=1.7
	# require passlib 1.7+ (on Centos install with python-pip)
	if [ $(compare_version $version $module) -le 0 ]; then
		true
	else
		false
	fi
}

py_sha512() {
	local password=$1 salt=$2 _outvar=$3 py_hash=

	if has_passlib; then
		# use py-passlib if available so extra rounds can be used
		py_hash=$(python -c "from passlib.hash import sha512_crypt; import sys; \
				print sha512_crypt.using(salt=sys.argv[1],rounds=sys.argv[2]).hash(sys.argv[3])" \
				$salt $ROUNDS $password 2>/dev/null)
	else
		# fall back to crypt()
		py_hash=$(python -c "import sys, crypt; \
				print crypt.crypt(sys.argv[1],'\$6\$' + sys.argv[2] + '\$')" \
				$password $salt 2>/dev/null)
	fi

	eval "$_outvar=\$py_hash"
}

check_mkpasswd() {
	local cmd= _ret_interpreter= _outvar=$1 tmp=$(mktemp)

	mkpasswd -h &>$tmp

	if grep "\-rounds" $tmp 1>/dev/null; then
		cmd=debian
	elif grep ^'BusyBox' $tmp 1>/dev/null; then
		if has_passlib; then
			# prefer py-passlib as it allows
			# number of rounds to be used
			cmd=python
		else
			cmd=busybox
		fi
	else
		# centos will use python crypt() on a default install
		# systems without python will use perl crypt()
		check_interpreters _ret_interpreter
		cmd=$_ret_interpreter
	fi

	eval "$_outvar=\$cmd"
	rm -f $tmp
}

check_interpreters() {
	# prefer python over perl as many package managers use python
	local x= cmd= _outvar=$1 languages="python perl"

	for x in $languages; do
		if $x --version &>/dev/null; then
			cmd=$x
			break
		fi
	done

	if [ -z "$cmd" ]; then
		printf "\nA suitable mkpasswd / Perl or Python not found: exiting\n"
		catch_exits
	fi

	eval "$_outvar=\$cmd"
}

sanitize_path() {
	echo /${1#*/} |tr -cd '[:alnum:] [=@=] [=.=] [=-=] [=/=] [=_=]' \
		|tr -s '@.-/_' |awk '{print tolower($0)}'
}

sanitize_user() {
	echo $@ |tr -d [[:space:]] | tr -cd '[:alnum:] [=@=] [=.=] [=-=] [=_=]' \
		|tr -s '@.-_' |awk '{print tolower($0)}'
}

check_config() {
	local ans= dir=$(dirname $1)

	if [ ! -d $dir ]; then
		printf "create password directory: '$dir' ? [Y/n] "; read ans
		case "$ans" in
			''|y*|Y*) printf "creating password directory: '$dir'\n"
				  mkdir -p $dir;;
			       *) catch_exits;;
		esac
	fi
}

check_user() {
	local username=$1

	if grep ^"$username:" $PW_FILE &>/dev/null; then
		printf "\nWARN: username '$username' exists in: $PW_FILE\n\n"
	fi
}

get_user() {
	local username= _outvar=$1

	printf "New username: "; read -t 60 username
	if [ -z "$username" ]; then
		printf "\nno user input\n"
		catch_exits
	else
		username=$(sanitize_user $username)
		check_user $username
	fi

	eval "$_outvar=\$username"
}

get_passwd() {
	local pass1= pass2= _ret_method= _ret_hash= username=$1 cmd=$2 _outvar=$3

	printf "New password: "; read -st 60 pass1
	printf "\nRe-type new password: "; read -st 60 pass2

	if [ -n "$pass1" ] && [ "$pass1" = "$pass2" ]; then
		# get methods separately as hash generation can take time with high # rounds
		check_sha512_method $cmd _ret_method
		printf "\n\nUsing hash method => $_ret_method ..."
		# disable CTRL+Z - hash generation can be stopped with CTRL+C
		trap "" SIGTSTP
		# Start progress meter in the background
		progress & 2>/dev/null
		# Save progress() pid
		PID=$!
		# generate hashes
		create_sha512_hash $pass1 $cmd _ret_hash
		# Kill progress
		kill -9 $PID &>/dev/null
		printf "...done."
		# display hash
		printf "\n\n$username:$_ret_hash\n"
	else
		printf "\n$(basename $0): password verification error\n"
		catch_exits
	fi

	eval "$_outvar=\$_ret_hash"
}

progress(){
	while true; do
		# animate cursor
		for c in / - \\ \|; do
			printf '%s\b' "$c";
			sleep 0.1;
		done
		# progress dots
		printf "."
	done
}

update_passfile() {
	local ans= username=$1 password=$2
	usercheck=$(check_user $username)

	if [ -z "$usercheck" ]; then
		echo "$username:$password" >> $PW_FILE
	else
		printf "\nreplace $username:passwd in $PW_FILE ? [y/N]: "; read -t 60 ans
		case "$ans" in
			y*|Y*) sed -i "s|^$username:.*|$username:$password|" $PW_FILE;;
			    *) catch_exits;;
		esac
	fi
	printf "\nupdated: $PW_FILE\n"
}

is_integer() {
	if [ "$1" -eq "$1" ] 2>/dev/null; then
		return 0
	else
		printf "$2 must be an integer.\n"
	fi
}

check_rounds() {
	is_integer $ROUNDS 'Number of rounds'

	# python passlib requires valid values
	if [ $ROUNDS -gt 999999999 ]; then
		printf "setting ROUNDS to maximum level of 999,999,999\n\n"
		ROUNDS=999999999
	elif [ $ROUNDS -lt 5000 ]; then
		 printf "setting ROUNDS to default level of 5,000\n\n"
		ROUNDS=5000
	fi
}

get_options() {
	local update= opts= _outvar=$(echo $@ | awk '{print $NF}')

	while getopts :f:r:hn opts "$@"
	do
		case "$opts" in
			n) update='false' ;;
			f) PW_FILE=$(sanitize_path $OPTARG); check_config $PW_FILE ;;
			r) ROUNDS=$OPTARG; check_rounds ;;
			h) usage ;;
		       \?) usage ;;
			:) printf "-$OPTARG missing argument\n"; catch_exits;;
		esac
	done

	eval "$_outvar=\$update"
}

main() {
	local user= cmd= _ret_user= _ret_cmd= _ret_pass_hash= _ret_update=

	get_options $@ _ret_update
	check_config $PW_FILE
	check_mkpasswd _ret_cmd
	get_user _ret_user

	user=$_ret_user
	cmd=$_ret_cmd

	get_passwd $user $cmd _ret_pass_hash

	if [ "$_ret_update" != "false" ]; then
		update_passfile $_ret_user $_ret_pass_hash
	fi
}

## START ##
trap catch_exits 1 2 3 15 20
main $@
exit $?

